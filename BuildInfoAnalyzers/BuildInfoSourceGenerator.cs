#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

namespace BuildInfoAnalyzers;

[Generator]
public class BuildInfoSourceGenerator : IIncrementalGenerator
{
    private const string AttributeText = """

                                         using System;
                                         namespace BuildInfoAnalyzers
                                         {
                                             [AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
                                             internal sealed class CompilerVisiblePropertyAttribute : Attribute
                                             {
                                                 public CompilerVisiblePropertyAttribute() { }
                                             }
                                         }

                                         """;

    /// <summary>
    /// Initializes the BuildInfoSourceGenerator and registers the attribute and source output.
    /// </summary>
    /// <param name="context">The Roslyn generator initialization context.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Inject the attribute source into the user's compilation
        context.RegisterPostInitializationOutput(i => i.AddSource(
            "CompilerVisiblePropertyAttribute.g.cs",
            SourceText.From(AttributeText, Encoding.UTF8)));

        // Find all partial static classes named "BuildInfo"
        IncrementalValuesProvider<INamedTypeSymbol> classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax { Identifier.ValueText: "BuildInfo" },
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null)!;

        // Get the build properties from the .csproj file
        IncrementalValueProvider<AnalyzerConfigOptions> buildProperties = context.AnalyzerConfigOptionsProvider
            .Select((provider, _) => provider.GlobalOptions);

        // Combine the class symbols with the build properties
        var combined = classDeclarations.Combine(buildProperties);

        // Register the final source output
        context.RegisterSourceOutput(combined,
            static (spc, source) => Execute(spc, source.Left, source.Right));
    }

    /// <summary>
    /// Gets the semantic symbol for a partial static class named BuildInfo, or null if not valid.
    /// </summary>
    /// <param name="context">The generator syntax context.</param>
    /// <returns>The INamedTypeSymbol for the BuildInfo class, or null.</returns>
    private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Check that the class is partial and static before getting the symbol
        if (classDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword) &&
            classDeclarationSyntax.Modifiers.Any(SyntaxKind.StaticKeyword))
        {
            if (context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is { } namedTypeSymbol)
            {
                return namedTypeSymbol;
            }
        }

        return null;
    }

    /// <summary>
    /// Generates and adds the BuildInfo source file to the compilation.
    /// </summary>
    /// <param name="context">The source production context.</param>
    /// <param name="classSymbol">The BuildInfo class symbol.</param>
    /// <param name="options">The analyzer config options (MSBuild properties).</param>
    private static void Execute(SourceProductionContext context, INamedTypeSymbol classSymbol,
        AnalyzerConfigOptions options)
    {
        // Call the generation method to get the source code.
        string sourceCode = GenerateSource(classSymbol, options);

        // Add the generated source file to the compilation.
        context.AddSource($"{classSymbol.Name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
    }

    /// <summary>
    /// Generates the source code for the BuildInfo class based on the symbol and MSBuild options.
    /// </summary>
    /// <param name="classSymbol">The BuildInfo class symbol.</param>
    /// <param name="options">The analyzer config options (MSBuild properties).</param>
    /// <returns>The generated C# source code for the BuildInfo class.</returns>
    internal static string GenerateSource(INamedTypeSymbol classSymbol, AnalyzerConfigOptions options)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var sourceBuilder = new StringBuilder($$"""

                                                // <auto-generated/>
                                                namespace {{namespaceName}}
                                                {
                                                    public static partial class {{classSymbol.Name}}
                                                    {

                                                """);

        foreach (var member in classSymbol.GetMembers())
        {
            if (member is not IPropertySymbol property) continue;

            if (property.GetAttributes().Any(attr =>
                    attr.AttributeClass?.ToDisplayString() ==
                    "BuildInfoAnalyzers.CompilerVisiblePropertyAttribute"))
            {
                string propertyKey = $"build_property.{property.Name}";
                if (options.TryGetValue(propertyKey, out var propertyValue))
                {
                    // Get the full type name of the property (e.g., "string", "int", "bool")
                    string typeName = property.Type.ToDisplayString();
                    string formattedValue;

                    // Format the value based on its type. Strings get quotes, others do not.
                    switch (typeName)
                    {
                        case "string":
                        case "System.String":
                            formattedValue = $"\"{propertyValue.Replace("\"", "\\\"")}\"";
                            break;
                        default:
                            // For non-string types like int, bool, double, etc.,
                            // use the value directly. Assumes the value in the .csproj is valid.
                            formattedValue = propertyValue;
                            break;
                    }

                    sourceBuilder.AppendLine(
                        $"        public static partial {typeName} {property.Name} => {formattedValue};");
                }
            }
        }

        sourceBuilder.AppendLine("    }");
        sourceBuilder.AppendLine("}");

        return sourceBuilder.ToString();
    }
}